Kubernetize - Deploy the application to kubernetes cluster
In this lab, we will deploy the application by leveraging the docker image, to a kubernetes cluster.

Learning Outcomes
After completing the lab, you will be able to:

Describe how to create Kubernetes Objects

Describe how to write yaml files for pods, deployments and services

Run your Spring boot application within a kubernetes cluster

Basics of K8s service discovery concepts

Starting to Kubernetize
Before starting the lab, verify the pages image created in the previous lab exists in docker hub

Below the inital version of our deployment architecture which will evolve as our application evolves.

Complete the following tasks to implement the above architecture
All the below tasks are assumed to be implemented inside ~/.workspace/pages directory

Get your cluster namespace from the instructors, which will be used in the next steps.

Create a deployment/pages-namespace.yaml with the below manifest file.

apiVersion: v1
kind: Namespace
metadata:
  name: [student-name]
Create deployment/pages-deployment.yaml from the root project folder

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: pages
  name: pages
  namespace: [student-name]
spec:
  replicas: 1
  selector:
    matchLabels:
      app: pages
  strategy: {}
  template:
    metadata:
      labels:
        app: pages
    spec:
      containers:
        - image: [docker-username]/pages:[tag]
          name: pages
          ports:
            - containerPort: 8080
Create deployment/pages-service.yaml to expose the deployment as type NodePort

apiVersion: v1
kind: Service
metadata:
  labels:
    app: pages
  name: pages
  namespace: [student-name]
spec:
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app: pages
  type: NodePort
Deploy to minikube cluster
Start minikube locally minikube start --driver=virtualbox

Verify the kubectl context kubectl config get-contexts is set to minikube. If not, set it to minikube kubectl config use-context minikube

Create kubernetes objects

kubectl create namespace [student-name]
kubectl apply -f deployment/pages-service.yaml
kubectl apply -f deployment/pages-deployment.yaml
Verify the created objects

kubectl get deployment pages --namespace [student-name]
kubectl get service pages --namespace [student-name]
Set up [student-name] namespace to point to the current context

kubectl config set-context --current --namespace=[student-name]
Access the application by port-forwarding on localhost:8080

kubectl port-forward svc/pages 8080:8080

curl localhost:8080
Deploy the application to production cluster
Get the list of clusters configured inside kubeconfig file

kubectl config get-contexts

Copy the full name of the cluster emitted from command above. If you are using EKS (public cloud), it might look similar to arn:aws:---:cluster/*cluser-name*

Check with the instructors for the cluster name if you get more than one cluster apart from minikube from the previous command

Switch the kubectl context to point to the production cluster

kubectl config use-context [name of the cluster]

kubectl config set-context --current --namespace [student-name]
Create Kubernetes objects

Verify the created objects

Access the application by port-forwarding kubectl onto localhost:8080

Commit code changes to the git repository

git add .
git commit -m "Kubernetizing Spring Boot Application"
git push -u origin master